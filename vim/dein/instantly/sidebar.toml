# actions
# a: action
# m: move
# c: copy
# D: delete
# l: expand
# ?: open help
[[plugins]]
repo = 'lambdalisue/fern.vim'
hook_add = '''
let g:fern#disable_default_mappings=1
nnoremap <silent><C-s> :Fern . -drawer -reveal=% -toggle -stay<CR>
function! s:init_fern() abort
  nmap <buffer><nowait> l <Plug>(fern-action-expand)
  nmap <buffer><nowait> h <Plug>(fern-action-collapse)
  nmap <buffer><nowait> D <Plug>(fern-action-remove)
  nmap <buffer><nowait> c <Plug>(fern-action-copy)
  nmap <buffer><nowait> m <Plug>(fern-action-move)
  nmap <buffer><nowait> N <Plug>(fern-action-new-file)
  nmap <buffer><nowait> <Return> <Plug>(fern-action-open)
endfunction
augroup fern-custom
  autocmd! *
  autocmd FileType fern call s:init_fern()
  autocmd FileType fern setlocal nonumber
augroup END
" show hidden files by default
let g:fern#default_hidden=1

" Auto reveal current file in fern
function! s:fern_reveal_current() abort
  " Skip if current buffer is fern itself
  if &filetype ==# 'fern'
    return
  endif

  " Skip if no fern window exists
  let l:fern_win = filter(range(1, winnr('$')), 'getwinvar(v:val, "&filetype") ==# "fern"')
  if empty(l:fern_win)
    return
  endif

  let l:current = expand('%:p')
  if !empty(l:current) && filereadable(l:current)
    " Save current window
    let l:winnr = winnr()
    try
      " Switch to fern window and reveal
      execute l:fern_win[0] . 'wincmd w'
      execute 'FernReveal ' . l:current
      " Return to original window
      execute l:winnr . 'wincmd w'
    catch
      " Ignore errors silently
    endtry
  endif
endfunction

" Auto reload fern when files are created/deleted
function! s:fern_reload() abort
  " Skip if current buffer is fern (to avoid flicker)
  if &filetype ==# 'fern'
    return
  endif

  " Skip if no fern window exists
  let l:fern_bufnr = filter(range(1, bufnr('$')), 'getbufvar(v:val, "&filetype") ==# "fern"')
  if empty(l:fern_bufnr)
    return
  endif

  " Use win_execute to reload fern without changing window
  for bufnr in l:fern_bufnr
    let l:win = bufwinnr(bufnr)
    if l:win > 0
      try
        " Execute normal R in the fern window
        call win_execute(win_getid(l:win), 'normal R')
      catch
        " Ignore errors
      endtry
    endif
  endfor

  " Reveal current file after reload
  call timer_start(100, {-> s:fern_reveal_current()})
endfunction

" Reveal current file when switching buffers
augroup fern-auto-reveal
  autocmd!
  autocmd BufEnter * call s:fern_reveal_current()
  " Auto reload on file write/new
  autocmd BufWritePost * call s:fern_reload()
  autocmd BufNewFile * call s:fern_reload()
  " Auto reload when external changes detected
  autocmd FocusGained * call s:fern_reload()
  autocmd CursorHold * call s:fern_reload()
augroup END

" Auto reload fern with timer (detect external changes)
if has('timers') && !exists('g:fern_auto_reload_timer')
  function! FernAutoReload(timer)
    " Skip if current buffer is fern
    if &filetype !=# 'fern'
      call s:fern_reload()
    endif
  endfunction
  let g:fern_auto_reload_timer = timer_start(1000, 'FernAutoReload', {'repeat': -1})
endif

'''

[[plugins]]
repo = 'lambdalisue/fern-git-status.vim'
hook_add = '''
" Disable listing ignored files/directories
let g:fern_git_status#disable_ignored=1
" Enable listing untracked files (new files)
let g:fern_git_status#disable_untracked=0
" Disable listing status of submodules
let g:fern_git_status#disable_submodules=1
" Enable listing status of directories
let g:fern_git_status#disable_directories=0
'''
depends = ['fern.vim']

[[plugins]]
repo = 'antoinemadec/FixCursorHold.nvim'

[[plugins]]
repo = 'LumaKernel/fern-mapping-reload-all.vim'
hook_add = '''
function s:init_fern_mapping_reload_all()
  nmap <buffer> R <Plug>(fern-action-reload:all)
endfunction
augroup my-fern-mapping-reload-all
  autocmd! *
  autocmd FileType fern call s:init_fern_mapping_reload_all()
augroup END
'''
depends = ['fern.vim']
